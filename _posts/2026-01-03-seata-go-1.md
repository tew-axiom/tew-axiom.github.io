---
title: Seata Go代码走读--整体架构和四大模式流程
date: 2026-01-03 23:46:02 +0800
categories: [Seata-Go, 代码走读]
tags: [seata, txn]
author: tew
description: Seata Go 代码走读系列，本篇主要介绍 Seata Go 整体架构、核心组件以及 AT,XA,TCC,Saga 四大模式的基本流程。 
mermaid: true
---

# 前言

Seata Go 是 Apache Seata 分布式事务框架的 Go 语言实现版本，它主要实现了与 Seata Java 版本的互操作性，使 Go 开发者也能够使用 Seata 来实现分布式事务。本文将从代码层面初步解析 Seata Go 的整体架构、核心组件以及四种事务模式（AT、XA、TCC、SAGA）的基本实现和生命周期。

# 一、整体架构

## 1.1 三大核心角色

### 1.1.1 Transaction Coordinator (TC)

TC 为事务协调器，负责维护全局事务和分支事务的状态，驱动全局事务的提交或回滚。在 Seata Go 中，TC 直接复用了 Seata Java 的实现，通过网络通信与 TM 和 RM 交互。

### 1.1.2 Transaction Manager (TM)

TM 是事务管理器，定义全局事务的范围，负责开启、提交或回滚全局事务。

可以主要关注下 `pkg/tm/global_transaction.go` 中 `GlobalTransactionManager` 的实现。

TM 提供以下三个核心方法：

1. **Begin**：开启全局事务
  - 构造 `GlobalBeginRequest` 请求
  - 通过 `getty.GetGettyRemotingClient().SendSyncRequest()` 向 TC 发送请求
  - 获取全局事务 XID 并绑定到 context

2. **Commit**：提交全局事务
  - 检查是否超时，超时则转为回滚
  - 仅 Launcher 角色执行提交
  - 使用 backoff 重试机制
  - 发送 `GlobalCommitRequest` 到 TC

3. **Rollback**：回滚全局事务
  - 仅 Launcher 角色执行回滚
  - 使用 backoff 重试机制
  - 发送 `GlobalRollbackRequest` 到 TC

### 1.1.3 Resource Manager (RM)

RM 是资源管理器，管理分支事务处理的资源，与 TC 通信以注册分支事务和报告分支事务状态，并驱动分支事务的提交 / 回滚。

可以从 `pkg/rm/rm_api.go` 注意到 RM 抽象了以下几个核心接口：

1. **Resource**：资源接口
```go
type Resource interface {
    GetResourceGroupId() string
    GetResourceId() string
    GetBranchType() branch.BranchType
}
```

2. **ResourceManagerInbound**：处理 TC 下发的分支事务操作
```go
type ResourceManagerInbound interface {
    BranchCommit(ctx context.Context, resource BranchResource) (branch.BranchStatus, error)
    BranchRollback(ctx context.Context, resource BranchResource) (branch.BranchStatus, error)
}
```

3. **ResourceManagerOutbound**：向 TC 发送请求
```go
type ResourceManagerOutbound interface {
    BranchRegister(ctx context.Context, param BranchRegisterParam) (int64, error)
    BranchReport(ctx context.Context, param BranchReportParam) error
    LockQuery(ctx context.Context, param LockQueryParam) (bool, error)
}
```

可以通过以上接口比较直观的看到 RM 整体的职责以及相关的行为抽象。

## 1.2 全局事务执行流程

这部分我们可以从 `pkg/tm/transaction_executor.go` 文件中

```go
func WithGlobalTx(ctx context.Context, gc *GtxConfig, business CallbackWithCtx) (re error) {
    if gc == nil {
        return fmt.Errorf("global transaction config info is required.")
    }
    if gc.Name == "" {
        return fmt.Errorf("global transaction name is required.")
    }
    // open global transaction for the first time
    if !IsSeataContext(ctx) {
        ctx = InitSeataContext(ctx)
    }
    if IsGlobalTx(ctx) {
        ctx = transferTx(ctx)
    }
    if re = begin(ctx, gc); re != nil {
        return
    }
    defer func() {
        var err error
        deferErr := recover()
        // no need to do second phase if propagation is some type e.g. NotSupported.
        if IsGlobalTx(ctx) {
        // business maybe to throw panic, so need to recover it here.
            if err = commitOrRollback(ctx, deferErr == nil && re == nil); err != nil {
                log.Errorf("global transaction xid %s, name %s second phase error: %v", GetXID(ctx), GetTxName(ctx), err)
            }
        }
        if re == nil {
            if deferErr != nil {
                // if deferErr is not an error, then convert it to error
                // this is because panic may be caused by non-error type e.g. panic("some string")
                // so we need to convert it to error type
                if _, ok := deferErr.(error); !ok {
                    deferErr = fmt.Errorf("%v", deferErr)
                }
                re = deferErr.(error)
            } else if err != nil {
                re = err
            }
        }
    }()
    re = business(ctx)
    return
}
```

的实现开始了解，这是全局事务的入口函数。

大致流程如下：

1. **初始化 Seata Context**
  - 检查是否已存在 Seata Context
  - 如果已存在全局事务，则转移事务上下文

2. **开启全局事务**
  - 调用 `begin()` 函数
  - 根据事务传播行为（Propagation）决定是否创建新事务

3. **执行业务逻辑**，在 defer 中捕获 panic 和错误

4. **提交或回滚**
  - 根据业务执行结果调用 `commitOrRollback()`
  - Launcher 角色负责二阶段操作
  - Participant 角色忽略二阶段操作

## 1.3 事务传播行为

上面提到开启全局事务时我们主要行为在 `begin()` 中，这里主要完成的工作为**根据传播行为确定其后续执行行为**。

1. **Required**
  - 如果当前存在事务，则加入该事务
  - 如果当前没有事务，则创建新事务

2. **RequiresNew**
  - 总是创建新事务
  - 如果当前存在事务，则挂起当前事务

3. **Supports**
  - 如果当前存在事务，则加入该事务
  - 如果当前没有事务，则以非事务方式执行

4. **NotSupported**
  - 总是以非事务方式执行
  - 如果当前存在事务，则挂起当前事务

5. **Never**
  - 总是以非事务方式执行
  - 如果当前存在事务，则抛出异常

6. **Mandatory**
  - 必须在事务中执行
  - 如果当前没有事务，则抛出异常

# 二、AT 模式

AT（Automatic Transaction）模式是 Seata 中最为经典的分布式事务模式，通过自动生成反向 SQL 的方式支持分支事务的回滚。

## 2.1 核心组件

### 2.1.1 ATSourceManager

[TODO]
